/*
 * === Add BackOfTheCard to Drawing ===
 * Version: 1.0.0
 * Date: 2025-01-19
 * Auteur: Rolland MELET & Claude Code
 * 
 * Description: Script qui g√©n√®re automatiquement un template BackOfTheCard 
 * √† partir d'un dessin Excalidraw existant contenant un seul objet.
 * 
 * Le script:
 * 1. Demande le nom du template
 * 2. G√©n√®re un fichier template avec exemples inspirants
 * 3. Ajoute visuellement le type d'objet dans le dessin
 * 4. Cr√©e l'embed BackOfTheCard

```javascript
 */

// V√©rification pr√©alable et logs de d√©marrage
console.log("üîß === V√âRIFICATION ENVIRONNEMENT ===");
console.log("üì¶ ExcalidrawAutomate (ea):", typeof ea, ea ? "‚úÖ" : "‚ùå");
console.log("üõ†Ô∏è Utils:", typeof utils, utils ? "‚úÖ" : "‚ùå");
console.log("üè† App object:", typeof app, app ? "‚úÖ" : "‚ùå");

if (!ea.verifyMinimumPluginVersion("2.0.0")) {
    console.error("‚ùå Version Excalidraw Plugin insuffisante");
    new Notice("‚ö†Ô∏è Version Excalidraw Plugin insuffisante. Minimum requis: 2.0.0");
    return;
}
console.log("‚úÖ Version plugin v√©rifi√©e");

// Configuration et constantes
const CONFIG = {
    version: "1.0.0",
    author: "Rolland MELET & Claude Code",
    debug: true
};

const TYPES_OBJETS = [
    "OBJET", "WORKFLOW", "PROCESSUS", "√âTAT", "ACTION", 
    "COMPORTEMENT", "VUE", "R√àGLE", "D√âCISION"
];

const COULEURS = {
    "OBJET": "#4CAF50",
    "WORKFLOW": "#FF9800", 
    "PROCESSUS": "#2196F3",
    "√âTAT": "#9C27B0",
    "ACTION": "#F44336",
    "COMPORTEMENT": "#00BCD4",
    "VUE": "#E91E63",
    "R√àGLE": "#795548",
    "D√âCISION": "#FFC107"
};

// Fonction de logging
function log(message, level = "info") {
    if (CONFIG.debug) {
        const timestamp = new Date().toLocaleTimeString();
        console.log(`[${timestamp}] BackOfTheCard: ${message}`);
    }
}

// Fonction principale
async function main() {
    try {
        log("=== D√âMARRAGE DU SCRIPT ===");
        log(`Add BackOfTheCard to Drawing v${CONFIG.version}`);

        // √âtape 1: V√©rifications pr√©alables
        log("üîç Recherche du fichier actif...");
        const activeFile = app.workspace.getActiveFile();
        
        log(`üìÅ activeFile found: ${activeFile ? 'YES' : 'NO'}`);
        if (activeFile) {
            log(`üìÑ File name: ${activeFile.name}`);
            log(`üîó File extension: ${activeFile.extension}`);
        }
        
        if (!activeFile) {
            log("‚ùå STOP: Aucun fichier ouvert");
            new Notice("‚ùå Veuillez ouvrir un fichier");
            return;
        }

        // V√©rifier si c'est un fichier Excalidraw 
        log("üîç V√©rification si fichier Excalidraw...");
        
        // M√©thode 1: Utiliser la fonction int√©gr√©e d'EA
        const isExcalidrawEA = ea.isExcalidrawFile(activeFile);
        log(`üé® EA.isExcalidrawFile: ${isExcalidrawEA ? 'YES' : 'NO'}`);
        
        // M√©thode 2: V√©rifier le frontmatter
        const fileContent = await app.vault.read(activeFile);
        const hasExcalidrawProperty = fileContent.includes("excalidraw-plugin: parsed");
        log(`üìã Frontmatter excalidraw-plugin: ${hasExcalidrawProperty ? 'YES' : 'NO'}`);
        
        const isExcalidrawFile = isExcalidrawEA || hasExcalidrawProperty;
        log(`‚úÖ Final check - Is Excalidraw: ${isExcalidrawFile ? 'YES' : 'NO'}`);
        
        if (!isExcalidrawFile) {
            log("‚ùå STOP: Ce n'est pas un fichier Excalidraw");
            new Notice("‚ùå Veuillez ouvrir un fichier Excalidraw (avec 'excalidraw-plugin: parsed')");
            return;
        }

        log(`üìÅ Fichier actif trouv√©: ${activeFile.name}`);
        log(`üìÇ Chemin complet: ${activeFile.path}`);

        // V√©rifier qu'il y a exactement un objet dans le dessin
        const elements = ea.getViewElements();
        log(`üîç Nombre d'√©l√©ments trouv√©s: ${elements.length}`);
        
        if (elements.length === 0) {
            log("‚ùå STOP: Aucun √©l√©ment dans le dessin");
            new Notice("‚ùå Aucun √©l√©ment dans le dessin. Cr√©ez d'abord un objet.");
            return;
        }
        
        if (elements.length > 1) {
            log(`‚ùå STOP: Trop d'√©l√©ments (${elements.length}) - doit √™tre exactement 1`);
            new Notice("‚ö†Ô∏è Le dessin doit contenir exactement UN objet. S√©lectionnez ou supprimez les autres √©l√©ments.");
            return;
        }

        log(`‚úÖ Objet unique trouv√© dans le dessin`);

        // √âtape 2: Demander le nom du template
        const nomTemplate = await askForTemplateName();
        if (!nomTemplate) return;

        log(`Nom du template: ${nomTemplate}`);

        // √âtape 3: Demander le type d'objet
        const typeObjet = await selectObjectType();
        if (!typeObjet) return;

        log(`Type d'objet: ${typeObjet}`);

        // √âtape 4: G√©n√©rer le template BackOfTheCard
        const templateContent = generateTemplate(nomTemplate, typeObjet);

        // √âtape 5: Cr√©er le fichier template
        const templateFile = await createTemplateFile(nomTemplate, templateContent);
        if (!templateFile) return;

        // √âtape 6: Ajouter le texte du type dans le dessin actuel
        await addTypeToCurrentDrawing(typeObjet, nomTemplate);

        // √âtape 7: Cr√©er l'embed dans le dessin actuel
        await addEmbedToCurrentDrawing(templateFile);

        log("‚úÖ BackOfTheCard ajout√© avec succ√®s!");
        new Notice(`‚úÖ Template "${nomTemplate}" cr√©√© et ajout√© au dessin`);

    } catch (error) {
        log(`‚ùå ERREUR: ${error.message}`, "error");
        new Notice(`‚ùå Erreur: ${error.message}`);
    }
}

// Demander le nom du template
async function askForTemplateName() {
    log("üìù Demande du nom du template...");
    const result = await utils.inputPrompt(
        "Nom du Template",
        "Entrez le nom du template √† cr√©er :",
        "",
        [{
            caption: "Cr√©er",
            action: () => true
        }]
    );
    
    if (!result || result.trim() === "") {
        log("‚ùå STOP: Nom du template vide ou annul√©");
        new Notice("‚ùå Nom du template requis");
        return null;
    }
    
    log(`‚úÖ Nom du template saisi: ${result.trim()}`);
    return result.trim();
}

// S√©lection du type d'objet
async function selectObjectType() {
    log("üéØ Demande du type d'objet...");
    const result = await utils.suggester(
        (item) => item,
        TYPES_OBJETS,
        false,
        "S√©lectionnez le type d'objet ProcessMetaLanguage :"
    );
    
    if (!result) {
        log("‚ùå STOP: Aucun type d'objet s√©lectionn√©");
        return null;
    }
    
    log(`‚úÖ Type d'objet s√©lectionn√©: ${result}`);
    return result;
}

// G√©n√©rateur de template avec exemples
function generateTemplate(nom, type) {
    const uid = generateUID(type);
    const date = new Date().toISOString().split('T')[0];
    
    // Construction du contenu par concat√©nation pour √©viter les conflits de template literals
    const templateHeader = `---
excalidraw-plugin: parsed
type: "template-${type.toLowerCase()}"
template_version: "1.0.0"
processmetalanguage_version: "2.3"
uid: "${uid}"
created: "${date}"
author: "${CONFIG.author}"
tags: [processmetalanguage, ${type.toLowerCase()}, template]
---`;

    const templateBody = `
# ${type}: ${nom}

## üìã M√©tadonn√©es

- **UID**: ${uid}
- **Type**: ${type}
- **Cr√©√©**: ${date}
- **Statut**: Brouillon
- **Version**: 1.0.0

## üìù Description

[D√©crivez ici l'objectif et le r√¥le de cet √©l√©ment]

**Exemple**: ` + getDescriptionExample(type) + `

## back of the Card

[Cette section contient les informations d√©taill√©es et techniques de l'√©l√©ment - le "verso" de la carte qui compl√®te la repr√©sentation visuelle du "recto"]

### Contexte d'utilisation
- **Quand l'utiliser** : [Situations appropri√©es]
- **Pr√©-requis** : [Conditions n√©cessaires]
- **Impact** : [Cons√©quences de son utilisation]

### D√©tails techniques
- **Impl√©mentation** : [Comment c'est r√©alis√© techniquement]
- **D√©pendances** : [Autres √©l√©ments n√©cessaires]
- **Configuration** : [Param√®tres sp√©cifiques]

## ‚öñÔ∏è Rules (R√®gles de Gestion)

### R√®gles M√©tier
- [ ] ` + getRuleExample(type, "business") + `
- [ ] ` + getRuleExample(type, "constraint") + `  
- [ ] ` + getRuleExample(type, "validation") + `

### R√®gles Techniques
- [ ] ` + getRuleExample(type, "technical") + `
- [ ] ` + getRuleExample(type, "performance") + `

### R√®gles de Transition
- [ ] ` + getRuleExample(type, "transition") + `

## üèóÔ∏è Propri√©t√©s

### Propri√©t√©s de Base
` + getPropertiesExample(type) + `

### Propri√©t√©s Sp√©cifiques
` + getSpecificPropertiesExample(type) + `

## üîó Relations

### Relations Entrantes
` + getRelationsExample(type, "incoming") + `

### Relations Sortantes
` + getRelationsExample(type, "outgoing") + `

## üîÑ √âtats et Transitions

### √âtats Possibles
` + getStatesExample(type) + `

### Conditions de Transition
` + getTransitionsExample(type) + `

## üìä M√©triques et KPIs

### Indicateurs de Performance
` + getMetricsExample(type) + `

## üîç Points de Contr√¥le

### Validations Requises
` + getValidationExample(type) + `

## üìö Documentation

### R√©f√©rences
- [Lien vers documentation m√©tier]
- [Lien vers sp√©cifications techniques]

### Exemples d'Usage
` + getUsageExample(type) + `

## üìù Notes

### √Ä Compl√©ter
- [ ] Finaliser les r√®gles m√©tier
- [ ] Valider les propri√©t√©s
- [ ] Tester les transitions
- [ ] Documenter les cas d'usage

### Historique
- ${date}: Cr√©ation du template

---
**Template g√©n√©r√© par ProcessMetaLanguage v${CONFIG.version}**
`;

    return templateHeader + templateBody;
}

// Exemples contextuels selon le type
function getDescriptionExample(type) {
    const examples = {
        "OBJET": "Cet objet repr√©sente une entit√© m√©tier (ex: Commande, Produit, Client) qui suit un processus d√©fini.",
        "WORKFLOW": "Ce workflow orchestre plusieurs processus pour atteindre un objectif business (ex: Traitement Commande Compl√®te).",
        "PROCESSUS": "Ce processus d√©crit le cycle de vie complet d'un objet de son √©tat initial √† son √©tat final.",
        "√âTAT": "Cet √©tat repr√©sente une situation sp√©cifique dans laquelle peut se trouver un objet √† un moment donn√©.",
        "ACTION": "Cette action d√©clenche une transition d'√©tat et peut modifier les propri√©t√©s de l'objet.",
        "COMPORTEMENT": "Ce comportement d√©finit une logique r√©utilisable applicable dans diff√©rents contextes.",
        "VUE": "Cette vue pr√©sente l'information de mani√®re adapt√©e √† un r√¥le utilisateur sp√©cifique.",
        "R√àGLE": "Cette r√®gle d√©finit une contrainte m√©tier qui doit √™tre respect√©e en permanence.",
        "D√âCISION": "Ce point de d√©cision oriente le flux selon des crit√®res d√©finis."
    };
    return examples[type] || "D√©crivez l'objectif de cet √©l√©ment";
}

function getRuleExample(type, ruleType) {
    const rules = {
        "business": "Respecter la logique m√©tier d√©finie",
        "constraint": "Valider les contraintes d'int√©grit√©",
        "validation": "V√©rifier les conditions d'entr√©e",
        "technical": "Respecter les standards techniques",
        "performance": "Maintenir les performances acceptables",
        "transition": "Autoriser le passage selon les conditions"
    };
    return rules[ruleType];
}

function getPropertiesExample(type) {
    return `- **nom**: Nom de l'√©l√©ment
- **description**: Description d√©taill√©e
- **statut**: √âtat courant (actif, inactif, suspendu)
- **propri√©taire**: Responsable de l'√©l√©ment
- **date_creation**: Date de cr√©ation
- **date_modification**: Derni√®re modification`;
}

function getSpecificPropertiesExample(type) {
    const specific = {
        "OBJET": "- **processus_id**: Identifiant du processus associ√©\n- **etat_courant**: √âtat actuel de l'objet\n- **proprietes_metier**: Donn√©es sp√©cifiques au domaine",
        "WORKFLOW": "- **processus_orchestres**: Liste des processus coordonn√©s\n- **declencheurs**: √âv√©nements qui initient le workflow\n- **points_synchronisation**: Moments de coordination",
        "PROCESSUS": "- **objet_cible**: Type d'objet g√©r√© par ce processus\n- **etats_possibles**: Liste des √©tats du processus\n- **etat_initial**: Point de d√©part\n- **etats_finaux**: Points d'arriv√©e",
        "√âTAT": "- **type_etat**: initial, interm√©diaire, final\n- **conditions_entree**: Conditions pour entrer dans cet √©tat\n- **conditions_sortie**: Conditions pour quitter cet √©tat\n- **actions_entree**: Actions √† ex√©cuter √† l'entr√©e\n- **actions_sortie**: Actions √† ex√©cuter √† la sortie"
    };
    return specific[type] || "- **propriete_specifique**: Valeur sp√©cifique au type";
}

function getRelationsExample(type, direction) {
    const relations = {
        "incoming": "- **predecesseur_1**: [Type] - Description de la relation\n- **parent**: [Type] - Relation hi√©rarchique",
        "outgoing": "- **successeur_1**: [Type] - Description de la relation\n- **enfants**: [Type] - Relations hi√©rarchiques"
    };
    return relations[direction];
}

function getStatesExample(type) {
    const states = {
        "OBJET": "- **Cr√©√©**: √âtat initial apr√®s cr√©ation\n- **En traitement**: Objet en cours de traitement\n- **Valid√©**: Objet approuv√©\n- **Termin√©**: √âtat final",
        "PROCESSUS": "- **Inactif**: Processus non d√©marr√©\n- **Actif**: Processus en cours d'ex√©cution\n- **Suspendu**: Processus temporairement arr√™t√©\n- **Termin√©**: Processus achev√©"
    };
    return states[type] || "- **√âtat_1**: Description\n- **√âtat_2**: Description";
}

function getTransitionsExample(type) {
    return `- **Condition_1**: Si [condition] alors [action]
- **Condition_2**: Quand [√©v√©nement] alors [transition]
- **R√®gle_m√©tier**: Selon [r√®gle] autoriser [passage]`;
}

function getMetricsExample(type) {
    return `- **Temps_moyen**: Dur√©e moyenne de traitement
- **Taux_succ√®s**: Pourcentage de succ√®s
- **Nombre_instances**: Instances actives`;
}

function getValidationExample(type) {
    return `- **Validation_1**: V√©rifier l'int√©grit√© des donn√©es
- **Validation_2**: Contr√¥ler les permissions
- **Validation_3**: Valider les r√®gles m√©tier`;
}

function getUsageExample(type) {
    return `### Sc√©nario Type
1. **D√©clenchement**: [√âv√©nement d√©clencheur]
2. **Traitement**: [√âtapes de traitement]
3. **R√©sultat**: [R√©sultat attendu]

### Cas Particuliers
- **Exception_1**: [Gestion du cas particulier]
- **Exception_2**: [Alternative ou contournement]`;
}

// G√©n√©rer un UID unique
function generateUID(type) {
    const prefix = type.substring(0, 3).toUpperCase();
    const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
    const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
    return `${prefix}${date}${random}`;
}

// Cr√©er le fichier template
async function createTemplateFile(nom, content) {
    try {
        const activeFile = app.workspace.getActiveFile();
        const targetFolder = activeFile.parent;
        const fileName = `template-${nom.replace(/\s+/g, '-').toLowerCase()}.md`;
        const filePath = `${targetFolder.path}/${fileName}`;
        
        log(`Cr√©ation du fichier: ${filePath}`);
        
        // V√©rifier si le fichier existe d√©j√†
        const existingFile = app.vault.getAbstractFileByPath(filePath);
        if (existingFile) {
            const overwrite = await utils.inputPrompt(
                "Fichier existant",
                `Le fichier "${fileName}" existe d√©j√†. Voulez-vous l'√©craser ? (oui/non)`,
                "non"
            );
            
            if (overwrite?.toLowerCase() !== "oui") {
                log("‚ùå STOP: Cr√©ation du template annul√©e par l'utilisateur");
                new Notice("‚ùå Cr√©ation annul√©e");
                return null;
            }
        }
        
        const file = await app.vault.create(filePath, content);
        log(`‚úÖ Fichier cr√©√©: ${fileName}`);
        
        return file;
        
    } catch (error) {
        log(`‚ùå Erreur cr√©ation fichier: ${error.message}`, "error");
        throw new Error(`Impossible de cr√©er le fichier: ${error.message}`);
    }
}

// Ajouter le texte du type dans le dessin actuel
async function addTypeToCurrentDrawing(type, nom) {
    try {
        log("Ajout du texte dans le dessin courant");
        
        // R√©initialiser EA pour travailler avec le dessin actuel
        ea.reset();
        ea.setView();
        
        // Obtenir les √©l√©ments existants pour positionner le texte
        const elements = ea.getViewElements();
        if (elements.length === 0) {
            log("‚ö†Ô∏è Aucun √©l√©ment trouv√© pour positionner le texte");
            return;
        }
        
        const firstElement = elements[0];
        log(`Element de r√©f√©rence trouv√©: ${firstElement.type} at (${firstElement.x}, ${firstElement.y})`);
        
        // Position du texte (au-dessus de l'√©l√©ment existant)
        const textX = firstElement.x;
        const textY = firstElement.y - 60;
        
        // Configurer le style du texte
        ea.style.strokeColor = COULEURS[type] || "#333333";
        ea.style.fontSize = 16;
        ea.style.fontFamily = 1;
        
        // Cr√©er le texte du type
        const typeText = ea.addText(textX, textY, `${type}: {{${nom}}}`, {
            textAlign: "left",
            verticalAlign: "middle"
        });
        
        // Appliquer les changements au dessin actuel
        await ea.addElementsToView(false, true);
        
        log(`‚úÖ Texte ajout√© au dessin: ${type}: {{${nom}}}`);
        
    } catch (error) {
        log(`‚ùå Erreur ajout texte: ${error.message}`, "error");
        console.error("Stack trace:", error.stack);
        // Ne pas bloquer le processus pour cette erreur
    }
}

// Ajouter l'embed dans le dessin actuel
async function addEmbedToCurrentDrawing(templateFile) {
    try {
        log("Cr√©ation de l'embed dans le dessin courant");
        
        // R√©initialiser EA pour travailler avec le dessin actuel
        ea.reset();
        ea.setView();
        
        // Obtenir les √©l√©ments actuels pour positionner l'embed
        const elements = ea.getViewElements();
        if (elements.length === 0) {
            log("‚ö†Ô∏è Aucun √©l√©ment trouv√© pour positionner l'embed");
            return;
        }
        
        // Chercher l'√©l√©ment le plus √† droite pour positionner l'embed
        let rightmostElement = elements[0];
        for (const element of elements) {
            if (element.x + element.width > rightmostElement.x + rightmostElement.width) {
                rightmostElement = element;
            }
        }
        
        log(`Element de r√©f√©rence pour embed: ${rightmostElement.type} at (${rightmostElement.x}, ${rightmostElement.y})`);
        
        // Position de l'embed (√† droite de l'√©l√©ment le plus √† droite)
        const embedX = rightmostElement.x + rightmostElement.width + 50;
        const embedY = rightmostElement.y;
        
        log(`Position embed calcul√©e: (${embedX}, ${embedY})`);
        
        // Cr√©er l'embed avec le lien vers le template
        const embedId = ea.addEmbeddable(embedX, embedY, 400, 300, templateFile.path);
        
        log(`Embed cr√©√© avec ID: ${embedId}`);
        log(`Lien template: ${templateFile.path}`);
        
        // Appliquer les changements au dessin actuel
        await ea.addElementsToView(false, true);
        
        log("‚úÖ Embed ajout√© au dessin courant");
        
    } catch (error) {
        log(`‚ùå Erreur cr√©ation embed: ${error.message}`, "error");
        console.error("Stack trace:", error.stack);
        throw new Error(`Impossible de cr√©er l'embed: ${error.message}`);
    }
}

// === EX√âCUTION ===
console.log("üöÄ === D√âMARRAGE SCRIPT BackOfTheCard ===");
console.log("üìã Objects disponibles - ea:", typeof ea, "- utils:", typeof utils);
console.log("üîß Config debug:", CONFIG.debug);

main().catch(error => {
    console.error("‚ùå Erreur fatale:", error);
    console.error("üîç Stack trace:", error.stack);
    new Notice("‚ùå Erreur fatale du script");
});